{"version":3,"file":"index.production.js","sources":["../../../query-core/build/lib/subscribable.mjs","../../../query-core/build/lib/utils.mjs","../../../query-core/build/lib/focusManager.mjs","../../../query-core/build/lib/onlineManager.mjs","../../../query-core/build/lib/retryer.mjs","../../../query-core/build/lib/logger.mjs","../../../query-core/build/lib/notifyManager.mjs","../../../query-core/build/lib/removable.mjs","../../../query-core/build/lib/query.mjs","../../../query-core/build/lib/queryCache.mjs","../../../query-core/build/lib/mutation.mjs","../../../query-core/build/lib/mutationCache.mjs","../../../query-core/build/lib/infiniteQueryBehavior.mjs","../../../query-core/build/lib/queryObserver.mjs","../../../query-core/build/lib/queriesObserver.mjs","../../../query-core/build/lib/infiniteQueryObserver.mjs","../../../query-core/build/lib/mutationObserver.mjs","../../../query-core/build/lib/hydration.mjs","../../src/reactBatchedUpdates.ts","../../src/setBatchUpdatesFn.ts","../../../../node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.1.1/node_modules/use-sync-external-store/shim/index.js","../../../../node_modules/.pnpm/use-sync-external-store@1.6.0_react@19.1.1/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js","../../src/useSyncExternalStore.ts","../../src/QueryClientProvider.tsx","../../src/isRestoring.tsx","../../src/QueryErrorResetBoundary.tsx","../../src/utils.ts","../../src/errorBoundaryUtils.ts","../../src/suspense.ts","../../src/useQueries.ts","../../src/useBaseQuery.ts","../../src/Hydrate.tsx","../../src/useMutation.ts","../../../query-core/build/lib/queryClient.mjs","../../src/infiniteQueryOptions.ts","../../src/queryOptions.ts","../../src/useInfiniteQuery.ts","../../src/useIsFetching.ts","../../src/useIsMutating.ts","../../src/usePrefetchInfiniteQuery.ts","../../src/usePrefetchQuery.ts","../../src/useQuery.ts","../../src/useSuspenseInfiniteQuery.ts","../../src/useSuspenseQueries.ts","../../src/useSuspenseQuery.ts"],"sourcesContent":["class Subscribable {\n  constructor() {\n    this.listeners = new Set();\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  subscribe(listener) {\n    const identity = {\n      listener\n    };\n    this.listeners.add(identity);\n    this.onSubscribe();\n    return () => {\n      this.listeners.delete(identity);\n      this.onUnsubscribe();\n    };\n  }\n\n  hasListeners() {\n    return this.listeners.size > 0;\n  }\n\n  onSubscribe() {// Do nothing\n  }\n\n  onUnsubscribe() {// Do nothing\n  }\n\n}\n\nexport { Subscribable };\n//# sourceMappingURL=subscribable.mjs.map\n","// TYPES\n// UTILS\nconst isServer = typeof window === 'undefined' || 'Deno' in window;\nfunction noop() {\n  return undefined;\n}\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nfunction difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nfunction timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return { ...arg3,\n      queryKey: arg1,\n      queryFn: arg2\n    };\n  }\n\n  return { ...arg2,\n    queryKey: arg1\n  };\n}\nfunction parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return { ...arg3,\n        mutationKey: arg1,\n        mutationFn: arg2\n      };\n    }\n\n    return { ...arg2,\n      mutationKey: arg1\n    };\n  }\n\n  if (typeof arg1 === 'function') {\n    return { ...arg2,\n      mutationFn: arg1\n    };\n  }\n\n  return { ...arg1\n  };\n}\nfunction parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    queryKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction parseMutationFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [{ ...arg2,\n    mutationKey: arg1\n  }, arg3] : [arg1 || {}, arg2];\n}\nfunction matchQuery(filters, query) {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale\n  } = filters;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive();\n\n    if (type === 'active' && !isActive) {\n      return false;\n    }\n\n    if (type === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetchStatus !== 'undefined' && fetchStatus !== query.state.fetchStatus) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nfunction matchMutation(filters, mutation) {\n  const {\n    exact,\n    fetching,\n    predicate,\n    mutationKey\n  } = filters;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nfunction hashQueryKeyByOptions(queryKey, options) {\n  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n * Hashes the value into a stable hash.\n */\n\nfunction hashQueryKey(queryKey) {\n  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {\n    result[key] = val[key];\n    return result;\n  }, {}) : val);\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nfunction partialMatchKey(a, b) {\n  return partialDeepEqual(a, b);\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nfunction replaceEqualDeep(a, b, depth = 0) {\n  if (a === b) {\n    return a;\n  }\n\n  if (depth > 500) return b;\n  const array = isPlainArray(a) && isPlainArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    const aSize = array ? a.length : Object.keys(a).length;\n    const bItems = array ? b : Object.keys(b);\n    const bSize = bItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key], depth + 1);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nfunction shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  const ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  const prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\nfunction sleep(timeout) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nfunction scheduleMicrotask(callback) {\n  sleep(0).then(callback);\n}\nfunction getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n\n  return;\n}\nfunction replaceData(prevData, data, options) {\n  // Use prev data if an isDataEqual function is defined and returns `true`\n  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {\n    return prevData;\n  } else if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data);\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data);\n  }\n\n  return data;\n}\n\nexport { difference, functionalUpdate, getAbortController, hashQueryKey, hashQueryKeyByOptions, isError, isPlainArray, isPlainObject, isQueryKey, isServer, isValidTimeout, matchMutation, matchQuery, noop, parseFilterArgs, parseMutationArgs, parseMutationFilterArgs, parseQueryArgs, partialDeepEqual, partialMatchKey, replaceAt, replaceData, replaceEqualDeep, scheduleMicrotask, shallowEqualObjects, sleep, timeUntilStale };\n//# sourceMappingURL=utils.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nclass FocusManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onFocus => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus(); // Listen to visibillitychange and focus\n\n\n        window.addEventListener('visibilitychange', listener, false);\n        window.addEventListener('focus', listener, false);\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener);\n          window.removeEventListener('focus', listener);\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(focused => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused);\n      } else {\n        this.onFocus();\n      }\n    });\n  }\n\n  setFocused(focused) {\n    const changed = this.focused !== focused;\n\n    if (changed) {\n      this.focused = focused;\n      this.onFocus();\n    }\n  }\n\n  onFocus() {\n    this.listeners.forEach(({\n      listener\n    }) => {\n      listener();\n    });\n  }\n\n  isFocused() {\n    if (typeof this.focused === 'boolean') {\n      return this.focused;\n    } // document global can be unavailable in react native\n\n\n    if (typeof document === 'undefined') {\n      return true;\n    }\n\n    return [undefined, 'visible', 'prerender'].includes(document.visibilityState);\n  }\n\n}\nconst focusManager = new FocusManager();\n\nexport { FocusManager, focusManager };\n//# sourceMappingURL=focusManager.mjs.map\n","import { Subscribable } from './subscribable.mjs';\nimport { isServer } from './utils.mjs';\n\nconst onlineEvents = ['online', 'offline'];\nclass OnlineManager extends Subscribable {\n  constructor() {\n    super();\n\n    this.setup = onOnline => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onOnline(); // Listen to online\n\n\n        onlineEvents.forEach(event => {\n          window.addEventListener(event, listener, false);\n        });\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          onlineEvents.forEach(event => {\n            window.removeEventListener(event, listener);\n          });\n        };\n      }\n\n      return;\n    };\n  }\n\n  onSubscribe() {\n    if (!this.cleanup) {\n      this.setEventListener(this.setup);\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$cleanup;\n\n      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);\n      this.cleanup = undefined;\n    }\n  }\n\n  setEventListener(setup) {\n    var _this$cleanup2;\n\n    this.setup = setup;\n    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);\n    this.cleanup = setup(online => {\n      if (typeof online === 'boolean') {\n        this.setOnline(online);\n      } else {\n        this.onOnline();\n      }\n    });\n  }\n\n  setOnline(online) {\n    const changed = this.online !== online;\n\n    if (changed) {\n      this.online = online;\n      this.onOnline();\n    }\n  }\n\n  onOnline() {\n    this.listeners.forEach(({\n      listener\n    }) => {\n      listener();\n    });\n  }\n\n  isOnline() {\n    if (typeof this.online === 'boolean') {\n      return this.online;\n    }\n\n    if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {\n      return true;\n    }\n\n    return navigator.onLine;\n  }\n\n}\nconst onlineManager = new OnlineManager();\n\nexport { OnlineManager, onlineManager };\n//# sourceMappingURL=onlineManager.mjs.map\n","import { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { sleep } from './utils.mjs';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * 2 ** failureCount, 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\nclass CancelledError {\n  constructor(options) {\n    this.revert = options == null ? void 0 : options.revert;\n    this.silent = options == null ? void 0 : options.silent;\n  }\n\n}\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  let promiseResolve;\n  let promiseReject;\n  const promise = new Promise((outerResolve, outerReject) => {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const shouldPause = () => !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        const canContinue = isResolved || !shouldPause();\n\n        if (canContinue) {\n          continueResolve(value);\n        }\n\n        return canContinue;\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(() => {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      const retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(() => {\n        if (shouldPause()) {\n          return pause();\n        }\n\n        return;\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn == null ? void 0 : continueFn();\n      return didContinue ? promise : Promise.resolve();\n    },\n    cancelRetry,\n    continueRetry\n  };\n}\n\nexport { CancelledError, canFetch, createRetryer, isCancelledError };\n//# sourceMappingURL=retryer.mjs.map\n","const defaultLogger = console;\n\nexport { defaultLogger };\n//# sourceMappingURL=logger.mjs.map\n","import { scheduleMicrotask } from './utils.mjs';\n\nfunction createNotifyManager() {\n  let queue = [];\n  let transactions = 0;\n\n  let notifyFn = callback => {\n    callback();\n  };\n\n  let batchNotifyFn = callback => {\n    callback();\n  };\n\n  const batch = callback => {\n    let result;\n    transactions++;\n\n    try {\n      result = callback();\n    } finally {\n      transactions--;\n\n      if (!transactions) {\n        flush();\n      }\n    }\n\n    return result;\n  };\n\n  const schedule = callback => {\n    if (transactions) {\n      queue.push(callback);\n    } else {\n      scheduleMicrotask(() => {\n        notifyFn(callback);\n      });\n    }\n  };\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n\n\n  const batchCalls = callback => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args);\n      });\n    };\n  };\n\n  const flush = () => {\n    const originalQueue = queue;\n    queue = [];\n\n    if (originalQueue.length) {\n      scheduleMicrotask(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach(callback => {\n            notifyFn(callback);\n          });\n        });\n      });\n    }\n  };\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n\n\n  const setNotifyFunction = fn => {\n    notifyFn = fn;\n  };\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n\n\n  const setBatchNotifyFunction = fn => {\n    batchNotifyFn = fn;\n  };\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction\n  };\n} // SINGLETON\n\nconst notifyManager = createNotifyManager();\n\nexport { createNotifyManager, notifyManager };\n//# sourceMappingURL=notifyManager.mjs.map\n","import { isValidTimeout, isServer } from './utils.mjs';\n\nclass Removable {\n  destroy() {\n    this.clearGcTimeout();\n  }\n\n  scheduleGc() {\n    this.clearGcTimeout();\n\n    if (isValidTimeout(this.cacheTime)) {\n      this.gcTimeout = setTimeout(() => {\n        this.optionalRemove();\n      }, this.cacheTime);\n    }\n  }\n\n  updateCacheTime(newCacheTime) {\n    // Default to 5 minutes (Infinity for server-side) if no cache time is set\n    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1000);\n  }\n\n  clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  }\n\n}\n\nexport { Removable };\n//# sourceMappingURL=removable.mjs.map\n","import { replaceData, noop, timeUntilStale, getAbortController } from './utils.mjs';\nimport { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { createRetryer, isCancelledError, canFetch } from './retryer.mjs';\nimport { Removable } from './removable.mjs';\n\n// CLASS\nclass Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState(this.options);\n    this.state = this.initialState;\n    this.scheduleGc();\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(\"Missing queryFn for queryKey '\" + this.options.queryHash + \"'\");\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;\n\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            this.logger.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \" + this.queryHash);\n          }\n\n          onError(new Error(this.queryHash + \" data is undefined\"));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);\n        (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.dispatch({\n          type: 'failed',\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState,\n              fetchStatus: 'idle'\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasData = typeof data !== 'undefined';\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\nexport { Query };\n//# sourceMappingURL=query.mjs.map\n","import { hashQueryKeyByOptions, parseFilterArgs, matchQuery } from './utils.mjs';\nimport { Query } from './query.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass QueryCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.queries = [];\n    this.queriesMap = {};\n  }\n\n  build(client, options, state) {\n    var _options$queryHash;\n\n    const queryKey = options.queryKey;\n    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        logger: client.getLogger(),\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n\n    return query;\n  }\n\n  add(query) {\n    if (!this.queriesMap[query.queryHash]) {\n      this.queriesMap[query.queryHash] = query;\n      this.queries.push(query);\n      this.notify({\n        type: 'added',\n        query\n      });\n    }\n  }\n\n  remove(query) {\n    const queryInMap = this.queriesMap[query.queryHash];\n\n    if (queryInMap) {\n      query.destroy();\n      this.queries = this.queries.filter(x => x !== query);\n\n      if (queryInMap === query) {\n        delete this.queriesMap[query.queryHash];\n      }\n\n      this.notify({\n        type: 'removed',\n        query\n      });\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        this.remove(query);\n      });\n    });\n  }\n\n  get(queryHash) {\n    return this.queriesMap[queryHash];\n  }\n\n  getAll() {\n    return this.queries;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  find(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.queries.find(query => matchQuery(filters, query));\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  findAll(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    return Object.keys(filters).length > 0 ? this.queries.filter(query => matchQuery(filters, query)) : this.queries;\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(event);\n      });\n    });\n  }\n\n  onFocus() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onFocus();\n      });\n    });\n  }\n\n  onOnline() {\n    notifyManager.batch(() => {\n      this.queries.forEach(query => {\n        query.onOnline();\n      });\n    });\n  }\n\n}\n\nexport { QueryCache };\n//# sourceMappingURL=queryCache.mjs.map\n","import { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Removable } from './removable.mjs';\nimport { createRetryer, canFetch } from './retryer.mjs';\n\n// CLASS\nclass Mutation extends Removable {\n  constructor(config) {\n    super();\n    this.defaultOptions = config.defaultOptions;\n    this.mutationId = config.mutationId;\n    this.mutationCache = config.mutationCache;\n    this.logger = config.logger || defaultLogger;\n    this.observers = [];\n    this.state = config.state || getDefaultState();\n    this.setOptions(config.options);\n    this.scheduleGc();\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  get meta() {\n    return this.options.meta;\n  }\n\n  setState(state) {\n    this.dispatch({\n      type: 'setState',\n      state\n    });\n  }\n\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer); // Stop the mutation from being garbage collected\n\n      this.clearGcTimeout();\n      this.mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    this.observers = this.observers.filter(x => x !== observer);\n    this.scheduleGc();\n    this.mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer\n    });\n  }\n\n  optionalRemove() {\n    if (!this.observers.length) {\n      if (this.state.status === 'loading') {\n        this.scheduleGc();\n      } else {\n        this.mutationCache.remove(this);\n      }\n    }\n  }\n\n  continue() {\n    var _this$retryer$continu, _this$retryer;\n\n    return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();\n  }\n\n  async execute() {\n    const executeMutation = () => {\n      var _this$options$retry;\n\n      this.retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject('No mutationFn found');\n          }\n\n          return this.options.mutationFn(this.state.variables);\n        },\n        onFail: (failureCount, error) => {\n          this.dispatch({\n            type: 'failed',\n            failureCount,\n            error\n          });\n        },\n        onPause: () => {\n          this.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: () => {\n          this.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode\n      });\n      return this.retryer.promise;\n    };\n\n    const restored = this.state.status === 'loading';\n\n    try {\n      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;\n\n      if (!restored) {\n        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;\n\n        this.dispatch({\n          type: 'loading',\n          variables: this.options.variables\n        }); // Notify cache callback\n\n        await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));\n        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));\n\n        if (context !== this.state.context) {\n          this.dispatch({\n            type: 'loading',\n            context,\n            variables: this.state.variables\n          });\n        }\n      }\n\n      const data = await executeMutation(); // Notify cache callback\n\n      await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));\n      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context)); // Notify cache callback\n\n      await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));\n      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));\n      this.dispatch({\n        type: 'success',\n        data\n      });\n      return data;\n    } catch (error) {\n      try {\n        var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;\n\n        // Notify cache callback\n        await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n\n        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context)); // Notify cache callback\n\n        await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, undefined, error, this.state.variables, this.state.context, this));\n        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, error, this.state.variables, this.state.context));\n        throw error;\n      } finally {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n    }\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error\n          };\n\n        case 'pause':\n          return { ...state,\n            isPaused: true\n          };\n\n        case 'continue':\n          return { ...state,\n            isPaused: false\n          };\n\n        case 'loading':\n          return { ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'loading',\n            variables: action.variables\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false\n          };\n\n        case 'error':\n          return { ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error'\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onMutationUpdate(action);\n      });\n      this.mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\nexport { Mutation, getDefaultState };\n//# sourceMappingURL=mutation.mjs.map\n","import { notifyManager } from './notifyManager.mjs';\nimport { Mutation } from './mutation.mjs';\nimport { matchMutation, noop } from './utils.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\n// CLASS\nclass MutationCache extends Subscribable {\n  constructor(config) {\n    super();\n    this.config = config || {};\n    this.mutations = [];\n    this.mutationId = 0;\n  }\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      logger: client.getLogger(),\n      mutationId: ++this.mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : undefined\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.mutations.push(mutation);\n    this.notify({\n      type: 'added',\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    this.mutations = this.mutations.filter(x => x !== mutation);\n    this.notify({\n      type: 'removed',\n      mutation\n    });\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.mutations.forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n\n  getAll() {\n    return this.mutations;\n  }\n\n  find(filters) {\n    if (typeof filters.exact === 'undefined') {\n      filters.exact = true;\n    }\n\n    return this.mutations.find(mutation => matchMutation(filters, mutation));\n  }\n\n  findAll(filters) {\n    return this.mutations.filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    var _this$resuming;\n\n    this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {\n      const pausedMutations = this.mutations.filter(x => x.state.isPaused);\n      return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop)), Promise.resolve()));\n    }).then(() => {\n      this.resuming = undefined;\n    });\n    return this.resuming;\n  }\n\n}\n\nexport { MutationCache };\n//# sourceMappingURL=mutationCache.mjs.map\n","function infiniteQueryBehavior() {\n  return {\n    onFetch: context => {\n      context.fetchFn = () => {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        let newPageParams = oldPageParams;\n        let cancelled = false;\n\n        const addSignalProperty = object => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              var _context$signal;\n\n              if ((_context$signal = context.signal) != null && _context$signal.aborted) {\n                cancelled = true;\n              } else {\n                var _context$signal2;\n\n                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener('abort', () => {\n                  cancelled = true;\n                });\n              }\n\n              return context.signal;\n            }\n          });\n        }; // Get query function\n\n\n        const queryFn = context.options.queryFn || (() => Promise.reject(\"Missing queryFn for queryKey '\" + context.options.queryHash + \"'\"));\n\n        const buildNewPages = (pages, param, page, previous) => {\n          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];\n          return previous ? [page, ...pages] : [...pages, page];\n        }; // Create function to fetch a page\n\n\n        const fetchPage = (pages, manual, param, previous) => {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const queryFnResult = queryFn(queryFnContext);\n          const promise = Promise.resolve(queryFnResult).then(page => buildNewPages(pages, param, page, previous));\n          return promise;\n        };\n\n        let promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          const manual = typeof pageParam !== 'undefined';\n          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param, true);\n        } // Refetch pages\n        else {\n          newPageParams = [];\n          const manual = typeof context.options.getNextPageParam === 'undefined';\n          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n          for (let i = 1; i < oldPages.length; i++) {\n            promise = promise.then(pages => {\n              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n              if (shouldFetchNextPage) {\n                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                return fetchPage(pages, manual, param);\n              }\n\n              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n            });\n          }\n        }\n\n        const finalPromise = promise.then(pages => ({\n          pages,\n          pageParams: newPageParams\n        }));\n        return finalPromise;\n      };\n    }\n  };\n}\nfunction getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nfunction getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    const nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n\n  return;\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nfunction hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    const previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n\n  return;\n}\n\nexport { getNextPageParam, getPreviousPageParam, hasNextPage, hasPreviousPage, infiniteQueryBehavior };\n//# sourceMappingURL=infiniteQueryBehavior.mjs.map\n","import { shallowEqualObjects, noop, isServer, isValidTimeout, timeUntilStale, replaceData } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { canFetch, isCancelledError } from './retryer.mjs';\n\nclass QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.options = options;\n    this.trackedProps = new Set();\n    this.selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n\n  bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.currentQuery.addObserver(this);\n\n      if (shouldFetchOnMount(this.currentQuery, this.options)) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n  }\n\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n  }\n\n  destroy() {\n    this.listeners = new Set();\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n    this.currentQuery.removeObserver(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryOptions(options);\n\n    if (process.env.NODE_ENV !== 'production' && typeof (options == null ? void 0 : options.isDataEqual) !== 'undefined') {\n      this.client.getLogger().error(\"The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option\");\n    }\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.currentQuery,\n        observer: this\n      });\n    }\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery();\n    const mounted = this.hasListeners(); // Fetch if there are subscribers\n\n    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n      this.executeFetch();\n    } // Update result\n\n\n    this.updateResult(notifyOptions); // Update stale interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.updateStaleTimeout();\n    }\n\n    const nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n      this.updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n\n  getOptimisticResult(options) {\n    const query = this.client.getQueryCache().build(this.client, options);\n    const result = this.createResult(query, options);\n\n    if (shouldAssignObserverCurrentProperties(this, result, options)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult everytime\n      // an observer reads an optimistic value.\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.currentResult = result;\n      this.currentResultOptions = this.options;\n      this.currentResultState = this.currentQuery.state;\n    }\n\n    return result;\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach(key => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n\n  getCurrentQuery() {\n    return this.currentQuery;\n  }\n\n  remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  }\n\n  refetch({\n    refetchPage,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        refetchPage\n      }\n    });\n  }\n\n  fetchOptimistic(options) {\n    const defaultedOptions = this.client.defaultQueryOptions(options);\n    const query = this.client.getQueryCache().build(this.client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n\n    return this.executeFetch({ ...fetchOptions,\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n    }).then(() => {\n      this.updateResult();\n      return this.currentResult;\n    });\n  }\n\n  executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    let promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  updateStaleTimeout() {\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    const time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    const timeout = time + 1;\n    this.staleTimeoutId = setTimeout(() => {\n      if (!this.currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n\n  computeRefetchInterval() {\n    var _this$options$refetch;\n\n    return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n  }\n\n  updateRefetchInterval(nextInterval) {\n    this.clearRefetchInterval();\n    this.currentRefetchInterval = nextInterval;\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.executeFetch();\n      }\n    }, this.currentRefetchInterval);\n  }\n\n  updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval(this.computeRefetchInterval());\n  }\n\n  clearStaleTimeout() {\n    if (this.staleTimeoutId) {\n      clearTimeout(this.staleTimeoutId);\n      this.staleTimeoutId = undefined;\n    }\n  }\n\n  clearRefetchInterval() {\n    if (this.refetchIntervalId) {\n      clearInterval(this.refetchIntervalId);\n      this.refetchIntervalId = undefined;\n    }\n  }\n\n  createResult(query, options) {\n    const prevQuery = this.currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.currentResult;\n    const prevResultState = this.currentResultState;\n    const prevResultOptions = this.currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n    const {\n      state\n    } = query;\n    let {\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      fetchStatus,\n      status\n    } = state;\n    let isPreviousData = false;\n    let isPlaceholderData = false;\n    let data; // Optimistically set result in fetching state if needed\n\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n        if (!dataUpdatedAt) {\n          status = 'loading';\n        }\n      }\n\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle';\n      }\n    } // Keep previous data if needed\n\n\n    if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n      data = prevQueryResult.data;\n      dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n      status = prevQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n        data = this.selectResult;\n      } else {\n        try {\n          this.selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n          this.selectResult = data;\n          this.selectError = null;\n        } catch (selectError) {\n          if (process.env.NODE_ENV !== 'production') {\n            this.client.getLogger().error(selectError);\n          }\n\n          this.selectError = selectError;\n        }\n      }\n    } // Use query data\n    else {\n      data = state.data;\n    } // Show placeholder data if needed\n\n\n    if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      let placeholderData; // Memoize placeholder data\n\n      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n\n    if (this.selectError) {\n      error = this.selectError;\n      data = this.selectResult;\n      errorUpdatedAt = Date.now();\n      status = 'error';\n    }\n\n    const isFetching = fetchStatus === 'fetching';\n    const isLoading = status === 'loading';\n    const isError = status === 'error';\n    const result = {\n      status,\n      fetchStatus,\n      isLoading,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading && isFetching,\n      data,\n      dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isLoading,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isPreviousData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      remove: this.remove\n    };\n    return result;\n  }\n\n  updateResult(notifyOptions) {\n    const prevResult = this.currentResult;\n    const nextResult = this.createResult(this.currentQuery, this.options);\n    this.currentResultState = this.currentQuery.state;\n    this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n\n    this.currentResult = nextResult; // Determine which callbacks to trigger\n\n    const defaultNotifyOptions = {\n      cache: true\n    };\n\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n\n      const {\n        notifyOnChangeProps\n      } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === 'function' ? notifyOnChangeProps() : notifyOnChangeProps;\n\n      if (notifyOnChangePropsValue === 'all' || !notifyOnChangePropsValue && !this.trackedProps.size) {\n        return true;\n      }\n\n      const includedProps = new Set(notifyOnChangePropsValue != null ? notifyOnChangePropsValue : this.trackedProps);\n\n      if (this.options.useErrorBoundary) {\n        includedProps.add('error');\n      }\n\n      return Object.keys(this.currentResult).some(key => {\n        const typedKey = key;\n        const changed = this.currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n\n    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n\n    this.notify({ ...defaultNotifyOptions,\n      ...notifyOptions\n    });\n  }\n\n  updateQuery() {\n    const query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === this.currentQuery) {\n      return;\n    }\n\n    const prevQuery = this.currentQuery;\n    this.currentQuery = query;\n    this.currentQueryInitialState = query.state;\n    this.previousQueryResult = this.currentResult;\n\n    if (this.hasListeners()) {\n      prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n\n  onQueryUpdate(action) {\n    const notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = !action.manual;\n    } else if (action.type === 'error' && !isCancelledError(action.error)) {\n      notifyOptions.onError = true;\n    }\n\n    this.updateResult(notifyOptions);\n\n    if (this.hasListeners()) {\n      this.updateTimers();\n    }\n  }\n\n  notify(notifyOptions) {\n    notifyManager.batch(() => {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);\n        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);\n        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, this.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        this.listeners.forEach(({\n          listener\n        }) => {\n          listener(this.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        this.client.getQueryCache().notify({\n          query: this.currentQuery,\n          type: 'observerResultsUpdated'\n        });\n      }\n    });\n  }\n\n}\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n} // this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\n\n\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult, options) {\n  // it is important to keep this condition like this for three reasons:\n  // 1. It will get removed in the v5\n  // 2. it reads: don't update the properties if we want to keep the previous\n  // data.\n  // 3. The opposite condition (!options.keepPreviousData) would fallthrough\n  // and will result in a bad decision\n  if (options.keepPreviousData) {\n    return false;\n  } // this means we want to put some placeholder data when pending and queryKey\n  // changed.\n\n\n  if (options.placeholderData !== undefined) {\n    // re-assign properties only if current data is placeholder data\n    // which means that data did not arrive yet, so, if there is some cached data\n    // we need to \"prepare\" to receive it\n    return optimisticResult.isPlaceholderData;\n  } // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n\n\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  } // basically, just keep previous properties if nothing changed\n\n\n  return false;\n}\n\nexport { QueryObserver };\n//# sourceMappingURL=queryObserver.mjs.map\n","import { difference, replaceAt } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { QueryObserver } from './queryObserver.mjs';\nimport { Subscribable } from './subscribable.mjs';\n\nclass QueriesObserver extends Subscribable {\n  constructor(client, queries) {\n    super();\n    this.client = client;\n    this.queries = [];\n    this.result = [];\n    this.observers = [];\n    this.observersMap = {};\n\n    if (queries) {\n      this.setQueries(queries);\n    }\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = new Set();\n    this.observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, notifyOptions) {\n    this.queries = queries;\n    notifyManager.batch(() => {\n      const prevObservers = this.observers;\n      const newObserverMatches = this.findMatchingObservers(this.queries); // set options for the new observers to notify of changes\n\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newObserversMap = Object.fromEntries(newObservers.map(observer => [observer.options.queryHash, observer]));\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.observers = newObservers;\n      this.observersMap = newObserversMap;\n      this.result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.onUpdate(observer, result);\n        });\n      });\n      this.notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.result;\n  }\n\n  getQueries() {\n    return this.observers.map(observer => observer.getCurrentQuery());\n  }\n\n  getObservers() {\n    return this.observers;\n  }\n\n  getOptimisticResult(queries) {\n    return this.findMatchingObservers(queries).map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n  }\n\n  findMatchingObservers(queries) {\n    const prevObservers = this.observers;\n    const prevObserversMap = new Map(prevObservers.map(observer => [observer.options.queryHash, observer]));\n    const defaultedQueryOptions = queries.map(options => this.client.defaultQueryOptions(options));\n    const matchingObservers = defaultedQueryOptions.flatMap(defaultedOptions => {\n      const match = prevObserversMap.get(defaultedOptions.queryHash);\n\n      if (match != null) {\n        return [{\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        }];\n      }\n\n      return [];\n    });\n    const matchedQueryHashes = new Set(matchingObservers.map(match => match.defaultedQueryOptions.queryHash));\n    const unmatchedQueries = defaultedQueryOptions.filter(defaultedOptions => !matchedQueryHashes.has(defaultedOptions.queryHash));\n    const matchingObserversSet = new Set(matchingObservers.map(match => match.observer));\n    const unmatchedObservers = prevObservers.filter(prevObserver => !matchingObserversSet.has(prevObserver));\n\n    const getObserver = options => {\n      const defaultedOptions = this.client.defaultQueryOptions(options);\n      const currentObserver = this.observersMap[defaultedOptions.queryHash];\n      return currentObserver != null ? currentObserver : new QueryObserver(this.client, defaultedOptions);\n    };\n\n    const newOrReusedObservers = unmatchedQueries.map((options, index) => {\n      if (options.keepPreviousData) {\n        // return previous data from one of the observers that no longer match\n        const previouslyUsedObserver = unmatchedObservers[index];\n\n        if (previouslyUsedObserver !== undefined) {\n          return {\n            defaultedQueryOptions: options,\n            observer: previouslyUsedObserver\n          };\n        }\n      }\n\n      return {\n        defaultedQueryOptions: options,\n        observer: getObserver(options)\n      };\n    });\n\n    const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);\n\n    return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);\n  }\n\n  onUpdate(observer, result) {\n    const index = this.observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.result = replaceAt(this.result, index, result);\n      this.notify();\n    }\n  }\n\n  notify() {\n    notifyManager.batch(() => {\n      this.listeners.forEach(({\n        listener\n      }) => {\n        listener(this.result);\n      });\n    });\n  }\n\n}\n\nexport { QueriesObserver };\n//# sourceMappingURL=queriesObserver.mjs.map\n","import { QueryObserver } from './queryObserver.mjs';\nimport { infiniteQueryBehavior, hasNextPage, hasPreviousPage } from './infiniteQueryBehavior.mjs';\n\nclass InfiniteQueryObserver extends QueryObserver {\n  // Type override\n  // Type override\n  // Type override\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n\n  setOptions(options, notifyOptions) {\n    super.setOptions({ ...options,\n      behavior: infiniteQueryBehavior()\n    }, notifyOptions);\n  }\n\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n\n  fetchNextPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'forward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  fetchPreviousPage({\n    pageParam,\n    ...options\n  } = {}) {\n    return this.fetch({ ...options,\n      meta: {\n        fetchMore: {\n          direction: 'backward',\n          pageParam\n        }\n      }\n    });\n  }\n\n  createResult(query, options) {\n    var _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet, _state$data, _state$data2;\n\n    const {\n      state\n    } = query;\n    const result = super.createResult(query, options);\n    const {\n      isFetching,\n      isRefetching\n    } = result;\n    const isFetchingNextPage = isFetching && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === 'forward';\n    const isFetchingPreviousPage = isFetching && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === 'backward';\n    return { ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),\n      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),\n      isFetchingNextPage,\n      isFetchingPreviousPage,\n      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage\n    };\n  }\n\n}\n\nexport { InfiniteQueryObserver };\n//# sourceMappingURL=infiniteQueryObserver.mjs.map\n","import { getDefaultState } from './mutation.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { shallowEqualObjects } from './utils.mjs';\n\n// CLASS\nclass MutationObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.updateResult();\n  }\n\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n\n  setOptions(options) {\n    var _this$currentMutation;\n\n    const prevOptions = this.options;\n    this.options = this.client.defaultMutationOptions(options);\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.currentMutation,\n        observer: this\n      });\n    }\n\n    (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);\n  }\n\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      var _this$currentMutation2;\n\n      (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);\n    }\n  }\n\n  onMutationUpdate(action) {\n    this.updateResult(); // Determine which callbacks to trigger\n\n    const notifyOptions = {\n      listeners: true\n    };\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    this.notify(notifyOptions);\n  }\n\n  getCurrentResult() {\n    return this.currentResult;\n  }\n\n  reset() {\n    this.currentMutation = undefined;\n    this.updateResult();\n    this.notify({\n      listeners: true\n    });\n  }\n\n  mutate(variables, options) {\n    this.mutateOptions = options;\n\n    if (this.currentMutation) {\n      this.currentMutation.removeObserver(this);\n    }\n\n    this.currentMutation = this.client.getMutationCache().build(this.client, { ...this.options,\n      variables: typeof variables !== 'undefined' ? variables : this.options.variables\n    });\n    this.currentMutation.addObserver(this);\n    return this.currentMutation.execute();\n  }\n\n  updateResult() {\n    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();\n    const isLoading = state.status === 'loading';\n    const result = { ...state,\n      isLoading,\n      isPending: isLoading,\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset\n    };\n    this.currentResult = result;\n  }\n\n  notify(options) {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.mutateOptions && this.hasListeners()) {\n        if (options.onSuccess) {\n          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;\n\n          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);\n        } else if (options.onError) {\n          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;\n\n          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, undefined, this.currentResult.error, this.currentResult.variables, this.currentResult.context);\n        }\n      } // Then trigger the listeners\n\n\n      if (options.listeners) {\n        this.listeners.forEach(({\n          listener\n        }) => {\n          listener(this.currentResult);\n        });\n      }\n    });\n  }\n\n}\n\nexport { MutationObserver };\n//# sourceMappingURL=mutationObserver.mjs.map\n","// TYPES\n// FUNCTIONS\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  };\n} // Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\n\n\nfunction dehydrateQuery(query) {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  };\n}\n\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === 'success';\n}\nfunction dehydrate(client, options = {}) {\n  const mutations = [];\n  const queries = [];\n\n  if (options.dehydrateMutations !== false) {\n    const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;\n    client.getMutationCache().getAll().forEach(mutation => {\n      if (shouldDehydrateMutation(mutation)) {\n        mutations.push(dehydrateMutation(mutation));\n      }\n    });\n  }\n\n  if (options.dehydrateQueries !== false) {\n    const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;\n    client.getQueryCache().getAll().forEach(query => {\n      if (shouldDehydrateQuery(query)) {\n        queries.push(dehydrateQuery(query));\n      }\n    });\n  }\n\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return;\n  }\n\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const mutations = dehydratedState.mutations || []; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(dehydratedMutation => {\n    var _options$defaultOptio;\n\n    mutationCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations),\n      mutationKey: dehydratedMutation.mutationKey\n    }, dehydratedMutation.state);\n  });\n  queries.forEach(({\n    queryKey,\n    state,\n    queryHash\n  }) => {\n    var _options$defaultOptio2;\n\n    const query = queryCache.get(queryHash); // Do not hydrate if an existing query exists with newer data\n\n    if (query) {\n      if (query.state.dataUpdatedAt < state.dataUpdatedAt) {\n        // omit fetchStatus from dehydrated state\n        // so that query stays in its current fetchStatus\n        const {\n          fetchStatus: _ignored,\n          ...dehydratedQueryState\n        } = state;\n        query.setState(dehydratedQueryState);\n      }\n\n      return;\n    } // Restore query\n\n\n    queryCache.build(client, { ...(options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries),\n      queryKey,\n      queryHash\n    }, // Reset fetch status to idle to avoid\n    // query being stuck in fetching state upon hydration\n    { ...state,\n      fetchStatus: 'idle'\n    });\n  });\n}\n\nexport { defaultShouldDehydrateMutation, defaultShouldDehydrateQuery, dehydrate, hydrate };\n//# sourceMappingURL=hydration.mjs.map\n","'use client'\nimport * as ReactDOM from 'react-dom'\n\nexport const unstable_batchedUpdates = ReactDOM.unstable_batchedUpdates\n","import { notifyManager } from '@tanstack/query-core'\nimport { unstable_batchedUpdates } from './reactBatchedUpdates'\n\nnotifyManager.setBatchNotifyFunction(unstable_batchedUpdates)\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","/**\n * @license React\n * use-sync-external-store-shim.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar React = require(\"react\");\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is,\n  useState = React.useState,\n  useEffect = React.useEffect,\n  useLayoutEffect = React.useLayoutEffect,\n  useDebugValue = React.useDebugValue;\nfunction useSyncExternalStore$2(subscribe, getSnapshot) {\n  var value = getSnapshot(),\n    _useState = useState({ inst: { value: value, getSnapshot: getSnapshot } }),\n    inst = _useState[0].inst,\n    forceUpdate = _useState[1];\n  useLayoutEffect(\n    function () {\n      inst.value = value;\n      inst.getSnapshot = getSnapshot;\n      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n    },\n    [subscribe, value, getSnapshot]\n  );\n  useEffect(\n    function () {\n      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n      return subscribe(function () {\n        checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n      });\n    },\n    [subscribe]\n  );\n  useDebugValue(value);\n  return value;\n}\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  inst = inst.value;\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(inst, nextValue);\n  } catch (error) {\n    return !0;\n  }\n}\nfunction useSyncExternalStore$1(subscribe, getSnapshot) {\n  return getSnapshot();\n}\nvar shim =\n  \"undefined\" === typeof window ||\n  \"undefined\" === typeof window.document ||\n  \"undefined\" === typeof window.document.createElement\n    ? useSyncExternalStore$1\n    : useSyncExternalStore$2;\nexports.useSyncExternalStore =\n  void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n","'use client'\n// Temporary workaround due to an issue with react-native uSES - https://github.com/TanStack/query/pull/3601\nimport { useSyncExternalStore as uSES } from 'use-sync-external-store/shim/index.js'\n\nexport const useSyncExternalStore = uSES\n","'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\nimport type { ContextOptions } from './types'\n\ndeclare global {\n  interface Window {\n    ReactQueryClientContext?: React.Context<QueryClient | undefined>\n  }\n}\n\nexport const defaultContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\nconst QueryClientSharingContext = React.createContext<boolean>(false)\n\n// If we are given a context, we will use it.\n// Otherwise, if contextSharing is on, we share the first and at least one\n// instance of the context across the window\n// to ensure that if React Query is used across\n// different bundles or microfrontends they will\n// all use the same **instance** of context, regardless\n// of module scoping.\nfunction getQueryClientContext(\n  context: React.Context<QueryClient | undefined> | undefined,\n  contextSharing: boolean,\n) {\n  if (context) {\n    return context\n  }\n  if (contextSharing && typeof window !== 'undefined') {\n    if (!window.ReactQueryClientContext) {\n      window.ReactQueryClientContext = defaultContext\n    }\n\n    return window.ReactQueryClientContext\n  }\n\n  return defaultContext\n}\n\nexport const useQueryClient = ({ context }: ContextOptions = {}) => {\n  const queryClient = React.useContext(\n    getQueryClientContext(context, React.useContext(QueryClientSharingContext)),\n  )\n\n  if (!queryClient) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return queryClient\n}\n\ntype QueryClientProviderPropsBase = {\n  client: QueryClient\n  children?: React.ReactNode\n}\ntype QueryClientProviderPropsWithContext = ContextOptions & {\n  contextSharing?: never\n} & QueryClientProviderPropsBase\ntype QueryClientProviderPropsWithContextSharing = {\n  context?: never\n  contextSharing?: boolean\n} & QueryClientProviderPropsBase\n\nexport type QueryClientProviderProps =\n  | QueryClientProviderPropsWithContext\n  | QueryClientProviderPropsWithContextSharing\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n  context,\n  contextSharing = false,\n}: QueryClientProviderProps): React.JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  if (process.env.NODE_ENV !== 'production' && contextSharing) {\n    client\n      .getLogger()\n      .error(\n        `The contextSharing option has been deprecated and will be removed in the next major version`,\n      )\n  }\n\n  const Context = getQueryClientContext(context, contextSharing)\n\n  return (\n    <QueryClientSharingContext.Provider value={!context && contextSharing}>\n      <Context.Provider value={client}>{children}</Context.Provider>\n    </QueryClientSharingContext.Provider>\n  )\n}\n","'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n","'use client'\nimport * as React from 'react'\n\n// CONTEXT\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: () => void\n  isReset: () => boolean\n  reset: () => void\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport interface QueryErrorResetBoundaryProps {\n  children:\n    | ((value: QueryErrorResetBoundaryValue) => React.ReactNode)\n    | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function'\n        ? (children as Function)(value)\n        : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  _useErrorBoundary: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary(...params)\n  }\n\n  return !!_useErrorBoundary\n}\n","'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  UseErrorBoundary,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (options.suspense || options.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  useErrorBoundary,\n  query,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  useErrorBoundary: UseErrorBoundary<\n    TQueryFnData,\n    TError,\n    TQueryData,\n    TQueryKey\n  >\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    shouldThrowError(useErrorBoundary, [result.error, query])\n  )\n}\n","import type { DefaultedQueryObserverOptions } from '@tanstack/query-core'\nimport type { QueryObserver } from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\nimport type { QueryObserverResult } from '@tanstack/query-core'\nimport type { QueryKey } from '@tanstack/query-core'\n\n/**\n * Ensures minimum staleTime and cacheTime values when suspense is enabled.\n * Despite the name, this function guards both staleTime and cacheTime to prevent\n * infinite re-render loops with synchronous queries.\n *\n * @deprecated in v5 - replaced by ensureSuspenseTimers\n */\nexport const ensureStaleTime = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000\n    }\n\n    if (typeof defaultedOptions.cacheTime === 'number') {\n      defaultedOptions.cacheTime = Math.max(defaultedOptions.cacheTime, 1000)\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => defaultedOptions?.suspense && willFetch(result, isRestoring)\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer\n    .fetchOptimistic(defaultedOptions)\n    .then(({ data }) => {\n      defaultedOptions.onSuccess?.(data as TData)\n      defaultedOptions.onSettled?.(data, null)\n    })\n    .catch((error) => {\n      errorResetBoundary.clearReset()\n      defaultedOptions.onError?.(error)\n      defaultedOptions.onSettled?.(undefined, error)\n    })\n","'use client'\nimport * as React from 'react'\n\nimport { QueriesObserver, notifyManager } from '@tanstack/query-core'\nimport { useSyncExternalStore } from './useSyncExternalStore'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureStaleTime,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type { OmitKeyof, QueryFunction, QueryKey } from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'context'\n>\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseQueryOptionsForUseQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? UseQueryOptionsForUseQueries<\n        TQueryFnData,\n        unknown,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedUseQueryResult rather than UseQueryResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? UseQueryResult<TData, TError>\n    : TInitialData extends TData\n    ? DefinedUseQueryResult<TData, TError>\n    : TInitialData extends () => infer TInitialDataResult\n    ? unknown extends TInitialDataResult\n      ? UseQueryResult<TData, TError>\n      : TInitialDataResult extends TData\n      ? DefinedUseQueryResult<TData, TError>\n      : UseQueryResult<TData, TError>\n    : UseQueryResult<TData, TError>\n  : UseQueryResult<TData, TError>\n\ntype GetUseQueryResult<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? GetDefinedOrUndefinedQueryResult<T, TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n    : // Fallback\n      UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  TResult extends any[] = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryOptionsForUseQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...TResult, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...TResult, GetOptions<Head>], [...TDepth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    UseQueryOptionsForUseQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  TResults extends any[] = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? UseQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...TResults, GetUseQueryResult<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<\n      [...Tail],\n      [...TResults, GetUseQueryResult<Head>],\n      [...TDepth, 1]\n    >\n  : T extends UseQueryOptionsForUseQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    UseQueryResult<unknown extends TData ? TQueryFnData : TData, TError>[]\n  : // Fallback\n    UseQueryResult[]\n\nexport function useQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...QueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): QueriesResults<T> {\n  const queryClient = useQueryClient({ context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((options) => {\n        const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, queryClient, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureStaleTime(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () => new QueriesObserver(queryClient, defaultedQueries),\n  )\n\n  const optimisticResult = observer.getOptimisticResult(defaultedQueries)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, { listeners: false })\n  }, [defaultedQueries, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result, isRestoring),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const options = defaultedQueries[index]\n        const queryObserver = observer.getObservers()[index]\n\n        if (options && queryObserver) {\n          if (shouldSuspend(options, result, isRestoring)) {\n            return fetchOptimistic(options, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(options, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const observerQueries = observer.getQueries()\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) =>\n      getHasError({\n        result,\n        errorResetBoundary,\n        useErrorBoundary: defaultedQueries[index]?.useErrorBoundary ?? false,\n        query: observerQueries[index]!,\n      }),\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return optimisticResult as QueriesResults<T>\n}\n","'use client'\nimport * as React from 'react'\n\nimport { notifyManager } from '@tanstack/query-core'\nimport { useSyncExternalStore } from './useSyncExternalStore'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { ensureStaleTime, fetchOptimistic, shouldSuspend } from './suspense'\nimport type { QueryKey, QueryObserver } from '@tanstack/query-core'\nimport type { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n) {\n  const queryClient = useQueryClient({ context: options.context })\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const defaultedOptions = queryClient.defaultQueryOptions(options)\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  // Include callbacks in batch renders\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(\n      defaultedOptions.onError,\n    )\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(\n      defaultedOptions.onSuccess,\n    )\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(\n      defaultedOptions.onSettled,\n    )\n  }\n\n  ensureStaleTime(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        queryClient,\n        defaultedOptions,\n      ),\n  )\n\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange))\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, { listeners: false })\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result, isRestoring)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      useErrorBoundary: defaultedOptions.useErrorBoundary,\n      query: observer.getCurrentQuery(),\n    })\n  ) {\n    throw result.error\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n","'use client'\nimport * as React from 'react'\n\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { HydrateOptions } from '@tanstack/query-core'\nimport type { ContextOptions } from './types'\n\nexport function useHydrate(\n  state: unknown,\n  options: HydrateOptions & ContextOptions = {},\n) {\n  const queryClient = useQueryClient({ context: options.context })\n\n  const optionsRef = React.useRef(options)\n  optionsRef.current = options\n\n  // Running hydrate again with the same queries is safe,\n  // it wont overwrite or initialize existing queries,\n  // relying on useMemo here is only a performance optimization.\n  // hydrate can and should be run *during* render here for SSR to work properly\n  React.useMemo(() => {\n    if (state) {\n      hydrate(queryClient, state, optionsRef.current)\n    }\n  }, [queryClient, state])\n}\n\nexport interface HydrateProps {\n  state?: unknown\n  options?: HydrateOptions\n  children?: React.ReactNode\n}\n\nexport const Hydrate = ({ children, options, state }: HydrateProps) => {\n  useHydrate(state, options)\n  return children as React.ReactElement\n}\n","'use client'\nimport * as React from 'react'\nimport {\n  MutationObserver,\n  notifyManager,\n  parseMutationArgs,\n} from '@tanstack/query-core'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport { useQueryClient } from './QueryClientProvider'\nimport { shouldThrowError } from './utils'\nimport type { MutationFunction, MutationKey } from '@tanstack/query-core'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationFn: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationKey: MutationKey,\n  mutationFn?: MutationFunction<TData, TVariables>,\n  options?: Omit<\n    UseMutationOptions<TData, TError, TVariables, TContext>,\n    'mutationKey' | 'mutationFn'\n  >,\n): UseMutationResult<TData, TError, TVariables, TContext>\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n>(\n  arg1:\n    | MutationKey\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg2?:\n    | MutationFunction<TData, TVariables>\n    | UseMutationOptions<TData, TError, TVariables, TContext>,\n  arg3?: UseMutationOptions<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const options = parseMutationArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        queryClient,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.useErrorBoundary, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","import { parseFilterArgs, parseQueryArgs, functionalUpdate, noop, hashQueryKey, partialMatchKey, hashQueryKeyByOptions } from './utils.mjs';\nimport { QueryCache } from './queryCache.mjs';\nimport { MutationCache } from './mutationCache.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior.mjs';\nimport { defaultLogger } from './logger.mjs';\n\n// CLASS\nclass QueryClient {\n  constructor(config = {}) {\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n    this.mountCount = 0;\n\n    if (process.env.NODE_ENV !== 'production' && config.logger) {\n      this.logger.error(\"Passing a custom logger has been deprecated and will be removed in the next major version.\");\n    }\n  }\n\n  mount() {\n    this.mountCount++;\n    if (this.mountCount !== 1) return;\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    this.mountCount--;\n    if (this.mountCount !== 0) return;\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    this.unsubscribeFocus = undefined;\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n    this.unsubscribeOnline = undefined;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  /**\n   * @deprecated This method will accept only queryKey in the next major version.\n   */\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  ensureQueryData(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const cachedData = this.getQueryData(parsedOptions.queryKey);\n    return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey,\n      state\n    }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({\n      queryKey\n    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));\n  }\n\n  getQueryState(queryKey,\n  /**\n   * @deprecated This filters will be removed in the next major version.\n   */\n  filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  /**\n   * @deprecated This method should be used with only one object argument.\n   */\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\nexport { QueryClient };\n//# sourceMappingURL=queryClient.mjs.map\n","import type { UseInfiniteQueryOptions } from './types'\nimport type {\n  InfiniteData,\n  NonUndefinedGuard,\n  OmitKeyof,\n  QueryKey,\n  WithRequired,\n} from '@tanstack/query-core'\n\ntype UseInfiniteQueryOptionsOmitted<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>,\n  'onSuccess' | 'onError' | 'onSettled' | 'refetchInterval'\n>\n\ntype ProhibitedInfiniteQueryOptionsKeyInV5 = keyof Pick<\n  UseInfiniteQueryOptionsOmitted,\n  'useErrorBoundary' | 'suspense'\n>\n\nexport type UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseInfiniteQueryOptionsOmitted<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData?: undefined\n}\n\nexport type DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseInfiniteQueryOptionsOmitted<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData:\n    | NonUndefinedGuard<InfiniteData<TQueryFnData>>\n    | (() => NonUndefinedGuard<InfiniteData<TQueryFnData>>)\n    | undefined\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: WithRequired<\n    OmitKeyof<\n      DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey>,\n      ProhibitedInfiniteQueryOptionsKeyInV5\n    >,\n    'queryKey'\n  >,\n): WithRequired<\n  OmitKeyof<\n    DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey>,\n    ProhibitedInfiniteQueryOptionsKeyInV5\n  >,\n  'queryKey'\n>\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: WithRequired<\n    OmitKeyof<\n      UndefinedInitialDataInfiniteOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryKey\n      >,\n      ProhibitedInfiniteQueryOptionsKeyInV5\n    >,\n    'queryKey'\n  >,\n): WithRequired<\n  OmitKeyof<\n    UndefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey>,\n    ProhibitedInfiniteQueryOptionsKeyInV5\n  >,\n  'queryKey'\n>\n\nexport function infiniteQueryOptions(options: unknown) {\n  return options\n}\n","import type {\n  InitialDataFunction,\n  NonUndefinedGuard,\n  OmitKeyof,\n  QueryKey,\n  WithRequired,\n} from '@tanstack/query-core'\nimport type { UseQueryOptions } from './types'\n\ntype UseQueryOptionsOmitted<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'onSuccess' | 'onError' | 'onSettled' | 'refetchInterval'\n>\n\ntype ProhibitedQueryOptionsKeyInV5 = keyof Pick<\n  UseQueryOptionsOmitted,\n  'useErrorBoundary' | 'suspense' | 'getNextPageParam' | 'getPreviousPageParam'\n>\n\nexport type UndefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptionsOmitted<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData?:\n    | undefined\n    | InitialDataFunction<NonUndefinedGuard<TQueryFnData>>\n    | NonUndefinedGuard<TQueryFnData>\n}\n\nexport type DefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptionsOmitted<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData:\n    | NonUndefinedGuard<TQueryFnData>\n    | (() => NonUndefinedGuard<TQueryFnData>)\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: WithRequired<\n    OmitKeyof<\n      DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n      ProhibitedQueryOptionsKeyInV5\n    >,\n    'queryKey'\n  >,\n): WithRequired<\n  OmitKeyof<\n    DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n    ProhibitedQueryOptionsKeyInV5\n  >,\n  'queryKey'\n>\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: WithRequired<\n    OmitKeyof<\n      UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n      ProhibitedQueryOptionsKeyInV5\n    >,\n    'queryKey'\n  >,\n): WithRequired<\n  OmitKeyof<\n    UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n    ProhibitedQueryOptionsKeyInV5\n  >,\n  'queryKey'\n>\n\nexport function queryOptions(options: unknown) {\n  return options\n}\n","'use client'\nimport { InfiniteQueryObserver, parseQueryArgs } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  InfiniteData,\n  NonUndefinedGuard,\n  QueryFunction,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport type {\n  DefinedUseInfiniteQueryResult,\n  UseInfiniteQueryOptions,\n  UseInfiniteQueryResult,\n} from './types'\n\n// HOOK\n\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  > & {\n    initialData:\n      | NonUndefinedGuard<InfiniteData<TQueryFnData>>\n      | (() => NonUndefinedGuard<InfiniteData<TQueryFnData>>)\n      | undefined\n  },\n): DefinedUseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError>\n/** @deprecated This function overload will be removed in the next major version. */\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey'\n  >,\n): UseInfiniteQueryResult<TData, TError>\n/** @deprecated This function overload will be removed in the next major version. */\nexport function useInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: Omit<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    'queryKey' | 'queryFn'\n  >,\n): UseInfiniteQueryResult<TData, TError>\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1:\n    | TQueryKey\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryFnData,\n        TQueryKey\n      >,\n  arg3?: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n): UseInfiniteQueryResult<TData, TError> {\n  const options = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver as typeof QueryObserver,\n  ) as UseInfiniteQueryResult<TData, TError>\n}\n","'use client'\nimport * as React from 'react'\nimport { notifyManager, parseFilterArgs } from '@tanstack/query-core'\n\nimport { useSyncExternalStore } from './useSyncExternalStore'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { ContextOptions } from './types'\nimport type { QueryFilters, QueryKey } from '@tanstack/query-core'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsFetching(filters?: QueryFilters, options?: Options): number\nexport function useIsFetching(\n  queryKey?: QueryKey,\n  filters?: QueryFilters,\n  options?: Options,\n): number\nexport function useIsFetching(\n  arg1?: QueryKey | QueryFilters,\n  arg2?: QueryFilters | Options,\n  arg3?: Options,\n): number {\n  const [filters, options = {}] = parseFilterArgs(arg1, arg2, arg3)\n  const queryClient = useQueryClient({ context: options.context })\n  const queryCache = queryClient.getQueryCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache],\n    ),\n    () => queryClient.isFetching(filters),\n    () => queryClient.isFetching(filters),\n  )\n}\n","'use client'\nimport * as React from 'react'\nimport { notifyManager, parseMutationFilterArgs } from '@tanstack/query-core'\nimport { useSyncExternalStore } from './useSyncExternalStore'\n\nimport { useQueryClient } from './QueryClientProvider'\nimport type { MutationFilters, MutationKey } from '@tanstack/query-core'\nimport type { ContextOptions } from './types'\n\ninterface Options extends ContextOptions {}\n\nexport function useIsMutating(\n  filters?: MutationFilters,\n  options?: Options,\n): number\nexport function useIsMutating(\n  mutationKey?: MutationKey,\n  filters?: Omit<MutationFilters, 'mutationKey'>,\n  options?: Options,\n): number\nexport function useIsMutating(\n  arg1?: MutationKey | MutationFilters,\n  arg2?: Omit<MutationFilters, 'mutationKey'> | Options,\n  arg3?: Options,\n): number {\n  const [filters, options = {}] = parseMutationFilterArgs(arg1, arg2, arg3)\n\n  const queryClient = useQueryClient({ context: options.context })\n  const mutationCache = queryClient.getMutationCache()\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        mutationCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [mutationCache],\n    ),\n    () => queryClient.isMutating(filters),\n    () => queryClient.isMutating(filters),\n  )\n}\n","import { useQueryClient } from './QueryClientProvider'\nimport type {\n  FetchInfiniteQueryOptions,\n  QueryKey,\n  WithRequired,\n} from '@tanstack/query-core'\n\nexport function usePrefetchInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: WithRequired<\n    FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n) {\n  const client = useQueryClient()\n  if (!client.getQueryState(options.queryKey)) {\n    client.prefetchInfiniteQuery(options)\n  }\n}\n","import { useQueryClient } from './QueryClientProvider'\nimport type {\n  FetchQueryOptions,\n  QueryKey,\n  WithRequired,\n} from '@tanstack/query-core'\n\nexport function usePrefetchQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: WithRequired<\n    FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n) {\n  const client = useQueryClient()\n  if (!client.getQueryState(options.queryKey)) {\n    client.prefetchQuery(options)\n  }\n}\n","'use client'\nimport { QueryObserver, parseQueryArgs } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  InitialDataFunction,\n  NonUndefinedGuard,\n  OmitKeyof,\n  QueryFunction,\n  QueryKey,\n} from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\n\n// HOOK\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & {\n    initialData:\n      | NonUndefinedGuard<TQueryFnData>\n      | (() => NonUndefinedGuard<TQueryFnData>)\n  },\n): DefinedUseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'initialData'\n  > & {\n    initialData?:\n      | undefined\n      | InitialDataFunction<NonUndefinedGuard<TQueryFnData>>\n      | NonUndefinedGuard<TQueryFnData>\n  },\n): UseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError>\n\n/** @deprecated This function overload will be removed in the next major version. */\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  >,\n): UseQueryResult<TData, TError>\n/** @deprecated This function overload will be removed in the next major version. */\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n/** @deprecated This function overload will be removed in the next major version. */\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  options?: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey'\n  >,\n): UseQueryResult<TData, TError>\n/** @deprecated This function overload will be removed in the next major version. */\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData?: () => undefined },\n): UseQueryResult<TData, TError>\n/** @deprecated This function overload will be removed in the next major version. */\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn' | 'initialData'\n  > & { initialData: TQueryFnData | (() => TQueryFnData) },\n): DefinedUseQueryResult<TData, TError>\n/** @deprecated This function overload will be removed in the next major version. */\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  queryKey: TQueryKey,\n  queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n  options?: OmitKeyof<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    'queryKey' | 'queryFn'\n  >,\n): UseQueryResult<TData, TError>\nexport function useQuery<\n  TQueryFnData,\n  TError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  arg1: TQueryKey | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg2?:\n    | QueryFunction<TQueryFnData, TQueryKey>\n    | UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  arg3?: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n  return useBaseQuery(parsedOptions, QueryObserver)\n}\n","import { InfiniteQueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  InfiniteQueryObserverSuccessResult,\n  OmitKeyof,\n  QueryKey,\n  QueryObserver,\n  WithRequired,\n} from '@tanstack/query-core'\nimport type {\n  UseInfiniteQueryOptions,\n  UseSuspenseInfiniteQueryResult,\n} from './types'\n\nexport type UseSuspenseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = WithRequired<\n  OmitKeyof<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryFnData,\n      TQueryKey\n    >,\n    | 'suspense'\n    | 'useErrorBoundary'\n    | 'enabled'\n    | 'placeholderData'\n    | 'networkMode'\n    | 'initialData'\n  >,\n  'queryKey'\n>\n\nexport function useSuspenseInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseSuspenseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey\n  >,\n): UseSuspenseInfiniteQueryResult<TData, TError> {\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      useErrorBoundary: true,\n      networkMode: 'always',\n    },\n    InfiniteQueryObserver as typeof QueryObserver,\n  ) as InfiniteQueryObserverSuccessResult<TData, TError>\n}\n","import { useQueries } from './useQueries'\nimport type {\n  UseQueryOptions,\n  UseSuspenseQueryOptions,\n  UseSuspenseQueryResult,\n} from './types'\nimport type { NetworkMode, QueryFunction } from '@tanstack/query-core'\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetSuspenseOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseSuspenseQueryOptions<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseSuspenseQueryOptions<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseSuspenseQueryOptions<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? UseSuspenseQueryOptions<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseSuspenseQueryOptions<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseSuspenseQueryOptions<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select?: (data: any) => infer TData\n      }\n    ? UseSuspenseQueryOptions<TQueryFnData, unknown, TData, TQueryKey>\n    : T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n      }\n    ? UseSuspenseQueryOptions<TQueryFnData, unknown, TQueryFnData, TQueryKey>\n    : // Fallback\n      UseSuspenseQueryOptions\n\ntype GetSuspenseResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseSuspenseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? UseSuspenseQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? UseSuspenseQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? UseSuspenseQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? UseSuspenseQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? UseSuspenseQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, any>\n        select?: (data: any) => infer TData\n      }\n    ? UseSuspenseQueryResult<unknown extends TData ? TQueryFnData : TData>\n    : T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, any>\n      }\n    ? UseSuspenseQueryResult<TQueryFnData>\n    : // Fallback\n      UseSuspenseQueryResult\n\n/**\n * SuspenseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type SuspenseQueriesOptions<\n  T extends Array<any>,\n  TResult extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseSuspenseQueryOptions>\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...TResult, GetSuspenseOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? SuspenseQueriesOptions<\n      [...Tail],\n      [...TResult, GetSuspenseOptions<Head>],\n      [...TDepth, 1]\n    >\n  : Array<unknown> extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends Array<\n      UseSuspenseQueryOptions<\n        infer TQueryFnData,\n        infer TError,\n        infer TData,\n        infer TQueryKey\n      >\n    >\n  ? Array<UseSuspenseQueryOptions<TQueryFnData, TError, TData, TQueryKey>>\n  : // Fallback\n    Array<UseSuspenseQueryOptions>\n\n/**\n * SuspenseQueriesResults reducer recursively maps type param to results\n */\nexport type SuspenseQueriesResults<\n  T extends Array<any>,\n  TResult extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseSuspenseQueryResult>\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...TResult, GetSuspenseResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? SuspenseQueriesResults<\n      [...Tail],\n      [...TResult, GetSuspenseResults<Head>],\n      [...TDepth, 1]\n    >\n  : T extends Array<\n      UseSuspenseQueryOptions<\n        infer TQueryFnData,\n        infer TError,\n        infer TData,\n        any\n      >\n    >\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    Array<\n      UseSuspenseQueryResult<\n        unknown extends TData ? TQueryFnData : TData,\n        TError\n      >\n    >\n  : // Fallback\n    Array<UseSuspenseQueryResult>\n\nexport function useSuspenseQueries<T extends any[]>({\n  queries,\n  context,\n}: {\n  queries: readonly [...SuspenseQueriesOptions<T>]\n  context?: UseQueryOptions['context']\n}): SuspenseQueriesResults<T> {\n  return useQueries({\n    queries: queries.map((query) => ({\n      ...query,\n      enabled: true,\n      useErrorBoundary: true,\n      suspense: true,\n      placeholderData: undefined,\n      networkMode: 'always' as NetworkMode,\n    })),\n    context,\n  }) as SuspenseQueriesResults<T>\n}\n","import { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type { QueryKey } from '@tanstack/query-core'\nimport type { UseSuspenseQueryOptions, UseSuspenseQueryResult } from './types'\n\nexport function useSuspenseQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(options: UseSuspenseQueryOptions<TQueryFnData, TError, TData, TQueryKey>) {\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      useErrorBoundary: true,\n      suspense: true,\n      placeholderData: undefined,\n      networkMode: 'always',\n      onSuccess: undefined,\n      onError: undefined,\n      onSettled: undefined,\n    },\n    QueryObserver,\n  ) as UseSuspenseQueryResult<TData, TError>\n}\n"],"names":["Subscribable","constructor","this","listeners","Set","subscribe","bind","listener","identity","add","onSubscribe","delete","onUnsubscribe","hasListeners","size","isServer","window","noop","isValidTimeout","value","Infinity","difference","array1","array2","filter","x","includes","timeUntilStale","updatedAt","staleTime","Math","max","Date","now","parseQueryArgs","arg1","arg2","arg3","isQueryKey","queryKey","queryFn","parseMutationArgs","mutationKey","mutationFn","parseFilterArgs","parseMutationFilterArgs","matchQuery","filters","query","type","exact","fetchStatus","predicate","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","fetching","hashQueryKey","status","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","partialDeepEqual","some","replaceEqualDeep","depth","array","isPlainArray","aSize","length","bItems","bSize","copy","equalItems","i","shallowEqualObjects","Array","isArray","o","hasObjectPrototype","ctor","prot","prototype","hasOwnProperty","toString","call","sleep","timeout","Promise","resolve","setTimeout","scheduleMicrotask","callback","then","replaceData","prevData","data","isDataEqual","structuralSharing","focusManager","super","setup","onFocus","addEventListener","removeEventListener","cleanup","setEventListener","_this$cleanup","undefined","_this$cleanup2","focused","setFocused","forEach","isFocused","document","visibilityState","onlineEvents","onlineManager","onOnline","event","online","setOnline","isOnline","navigator","onLine","defaultRetryDelay","failureCount","min","canFetch","networkMode","CancelledError","revert","silent","isCancelledError","createRetryer","config","continueFn","promiseResolve","promiseReject","isRetryCancelled","isResolved","promise","outerResolve","outerReject","shouldPause","onSuccess","reject","onError","pause","continueResolve","canContinue","onPause","onContinue","run","promiseOrValue","fn","error","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","cancel","cancelOptions","abort","continue","cancelRetry","continueRetry","defaultLogger","console","notifyManager","queue","transactions","notifyFn","batchNotifyFn","schedule","push","flush","originalQueue","batch","batchCalls","args","setNotifyFunction","setBatchNotifyFunction","createNotifyManager","Removable","destroy","clearGcTimeout","scheduleGc","cacheTime","gcTimeout","optionalRemove","updateCacheTime","newCacheTime","clearTimeout","Query","abortSignalConsumed","defaultOptions","setOptions","observers","cache","logger","initialState","initialData","hasData","initialDataUpdatedAt","dataUpdateCount","dataUpdatedAt","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchFailureReason","fetchMeta","isInvalidated","getDefaultState","meta","remove","setData","newData","dispatch","manual","setState","setStateOptions","_this$retryer","retryer","reset","observer","enabled","isDisabled","getObserversCount","getCurrentResult","isStaleByTime","_this$retryer2","find","shouldFetchOnWindowFocus","refetch","cancelRefetch","_this$retryer3","shouldFetchOnReconnect","addObserver","notify","removeObserver","invalidate","fetch","fetchOptions","_this$options$behavio","_context$fetchOptions","_this$retryer4","abortController","AbortController","getAbortController","queryFnContext","pageParam","addSignalProperty","object","defineProperty","enumerable","get","signal","context","fetchFn","_context$fetchOptions2","behavior","onFetch","revertState","_this$cache$config$on","_this$cache$config","_this$cache$config$on2","_this$cache$config2","onSettled","isFetchingOptimistic","_this$cache$config$on3","_this$cache$config3","_this$cache$config$on4","_this$cache$config4","Error","action","_action$meta","_action$dataUpdatedAt","reducer","onQueryUpdate","QueryCache","queries","queriesMap","build","client","_options$queryHash","getLogger","defaultQueryOptions","getQueryDefaults","queryInMap","clear","getAll","findAll","Mutation","mutationId","mutationCache","_this$retryer$continu","execute","async","executeMutation","_this$options$retry","variables","restored","_this$mutationCache$c3","_this$mutationCache$c4","_this$options$onSucce","_this$options2","_this$mutationCache$c5","_this$mutationCache$c6","_this$options$onSettl","_this$options3","_this$mutationCache$c","_this$mutationCache$c2","_this$options$onMutat","_this$options","onMutate","_this$mutationCache$c7","_this$mutationCache$c8","_this$options$onError","_this$options4","_this$mutationCache$c9","_this$mutationCache$c10","_this$options$onSettl2","_this$options5","failureReason","isPaused","onMutationUpdate","MutationCache","mutations","defaultMutationOptions","getMutationDefaults","resumePausedMutations","_this$resuming","resuming","pausedMutations","infiniteQueryBehavior","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchMore","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","pages","oldPageParams","pageParams","newPageParams","cancelled","buildNewPages","param","page","previous","fetchPage","_context$signal","_context$signal2","aborted","queryFnResult","getNextPageParam","getPreviousPageParam","hasNextPage","nextPageParam","hasPreviousPage","previousPageParam","QueryObserver","trackedProps","selectError","bindMethods","currentQuery","shouldFetchOnMount","executeFetch","updateTimers","shouldFetchOn","refetchOnReconnect","refetchOnWindowFocus","clearStaleTimeout","clearRefetchInterval","notifyOptions","prevOptions","prevQuery","getQueryCache","updateQuery","mounted","shouldFetchOptionally","updateResult","updateStaleTimeout","nextRefetchInterval","computeRefetchInterval","currentRefetchInterval","updateRefetchInterval","getOptimisticResult","createResult","optimisticResult","keepPreviousData","placeholderData","isPlaceholderData","shouldAssignObserverCurrentProperties","currentResult","currentResultOptions","currentResultState","trackResult","trackedResult","configurable","getCurrentQuery","fetchOptimistic","defaultedOptions","_fetchOptions$cancelR","throwOnError","staleTimeoutId","_this$options$refetch","refetchInterval","nextInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","clearInterval","prevResult","prevResultState","prevResultOptions","queryChange","queryInitialState","currentQueryInitialState","prevQueryResult","previousQueryResult","isPreviousData","_optimisticResults","fetchOnMount","fetchOptionally","isSuccess","select","selectFn","selectResult","isFetching","isLoading","isError","isInitialLoading","isFetched","isFetchedAfterMount","isRefetching","isLoadingError","isRefetchError","nextResult","defaultNotifyOptions","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","useErrorBoundary","typedKey","has","shouldNotifyListeners","retryOnMount","shouldLoadOnMount","refetchOnMount","field","suspense","QueriesObserver","observersMap","setQueries","onUpdate","prevObservers","newObserverMatches","findMatchingObservers","match","defaultedQueryOptions","newObservers","map","newObserversMap","fromEntries","newResult","hasIndexChange","index","getQueries","getObservers","prevObserversMap","Map","matchingObservers","flatMap","matchedQueryHashes","unmatchedQueries","matchingObserversSet","unmatchedObservers","prevObserver","getObserver","currentObserver","newOrReusedObservers","previouslyUsedObserver","concat","indexOf","slice","replaceAt","InfiniteQueryObserver","fetchNextPage","fetchPreviousPage","_state$fetchMeta","_state$fetchMeta$fetc","_state$fetchMeta2","_state$fetchMeta2$fet","_state$data","_state$data2","MutationObserver","mutate","_this$currentMutation","getMutationCache","currentMutation","_this$currentMutation2","mutateOptions","isPending","isIdle","_this$mutateOptions$o","_this$mutateOptions","_this$mutateOptions$o2","_this$mutateOptions2","_this$mutateOptions$o3","_this$mutateOptions3","_this$mutateOptions$o4","_this$mutateOptions4","defaultShouldDehydrateMutation","defaultShouldDehydrateQuery","hydrate","dehydratedState","queryCache","dehydratedMutation","_options$defaultOptio","_options$defaultOptio2","_ignored","dehydratedQueryState","unstable_batchedUpdates","ReactDOM","module","exports","React","require$$0","objectIs","is","y","useState","useEffect","useLayoutEffect","useDebugValue","checkIfSnapshotChanged","inst","latestGetSnapshot","getSnapshot","nextValue","shim","createElement","_useState","forceUpdate","useSyncExternalStoreShim_production","useSyncExternalStore","uSES","defaultContext","createContext","QueryClientSharingContext","getQueryClientContext","contextSharing","ReactQueryClientContext","useQueryClient","queryClient","useContext","IsRestoringContext","useIsRestoring","IsRestoringProvider","Provider","createValue","isReset","clearReset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","shouldThrowError","_useErrorBoundary","params","ensurePreventErrorBoundaryRetry","errorResetBoundary","useClearResetErrorBoundary","getHasError","ensureStaleTime","willFetch","isRestoring","shouldSuspend","useQueries","defaultedQueries","useMemo","useCallback","onStoreChange","suspensePromises","queryObserver","all","observerQueries","firstSingleResultWhichShouldThrow","_defaultedQueries$ind","_defaultedQueries$ind2","useBaseQuery","Observer","unsubscribe","useHydrate","optionsRef","useRef","current","children","queryDefaults","mutationDefaults","mountCount","mount","unsubscribeFocus","unsubscribeOnline","unmount","_this$unsubscribeFocu","_this$unsubscribeOnli","isMutating","getQueryData","_this$queryCache$find","ensureQueryData","parsedOptions","cachedData","fetchQuery","getQueriesData","queryKeyOrFilters","setQueryData","updater","input","functionalUpdate","setQueriesData","getQueryState","_this$queryCache$find2","removeQueries","resetQueries","refetchFilters","refetchQueries","cancelQueries","promises","invalidateQueries","_ref","_filters$refetchType","refetchType","_options$cancelRefetc","prefetchQuery","fetchInfiniteQuery","prefetchInfiniteQuery","getDefaultOptions","setDefaultOptions","setQueryDefaults","firstMatchingDefaults","setMutationDefaults","_defaulted","Context","dehydrateMutations","shouldDehydrateMutation","dehydrateMutation","dehydrateQueries","shouldDehydrateQuery","dehydrateQuery","mutateAsync"],"mappings":"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"}